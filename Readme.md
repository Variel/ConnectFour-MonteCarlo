# Connect-Four AI 몬테카를로 구현


## 흐름 따라가기


### 1. Program.cs

1. 프로그램의 시작은 `Program.cs` 에 `static void Main(string[] args)` 함수로 정의 되어 있습니다.
2. `Main` 함수에서 플레이어1과 플레이어2를 각각 설정(사람인지 AI인지)하고 (13 ~ 49 줄),
3. 각각의 플레이어에 대해 `Identifier` (식별자) 를 설정합니다. `Identifier` 란, 플레이어를 게임판 내에서 식별하기 위한 것으로, `true` 혹은 `false` 값으로 설정할 수 있습니다.
4. 이걸 좀 더 간단하게 생각하면 `true` 는 빨간색 플레이어로, `false` 는 노란색 플레이어로 생각하시면 됩니다. 데이터 처리의 효율성을 위해 색상 대신 `true`/`false` 값을 사용했습니다.
5. `Game` 개체를 생성하는 데에 인자로 집어 넣은 다음 (51 줄),
6. `game.StartLoop()`를 호출하여 게임을 구동합니다.


### 2. Game.cs

1. `Game` 클래스는 게임의 흐름을 제어하는 클래스입니다.
2. 사실상 `StartLoop` 함수만 볼 줄 알면 됩니다.
3. 즉, 현재 게임판(`Board`)의 상태를 가지고 있으면서, (9 줄)
4. 현재 차례의 플레이어에게 다음 수를 달라고 요청하며, (30 ~ 33 줄)
5. 받은 다음 수를 현재 플레이 중인 게임 판에 반영합니다. (35 줄)
6. 그 후 다음 차례가 누구인지 정해주고, (23, 37 줄)
7. 해당 수로 인해 게임이 끝났는지 판단합니다 (40 줄)
8. 게임이 끝나지 않았다면 3 ~ 5의 순서를 반복합니다. (41 줄)
9. 게임이 끝났다면 승리자를 표시해주고 함수를 종료합니다 (43 줄)
10. `PrintState` 함수와 `GetPlayerName` 함수는 흐름에 중요하지 않고, 알아볼 수 있을거라 설명을 생략합니다


### 3. Board.cs

#### 3.1. 게임판 데이터 저장
1. `Board` 클래스는 게임 판의 상태를 저장하고, 게임 판의 상태가 게임이 종료 된 상태인지, 종료 된 상태라면 누가 승리자인지 알려주는 클래스입니다.
2. `Board` 클래스는 `MakeMove` 와 `DetermineState` 가 가장 핵심적인 함수라고 보면 됩니다.
3. 일단 `Board` 클래스는 게임 판의 상태를 `_boardData` 변수(필드)에 저장합니다.
4. `_boardData` 필드는 bool? 타입의 이중 배열으로, 배열 각각의 요소는 `true` 혹은 `false` 혹은 `null` 값을 가질 수 있습니다.
5. 이 때 배열 요소의 값이 `null` 이라면 아무 것도 없는 상태, 즉 돌이 놓이지 않은 상태이며, `true` 혹은 `false` 일 경우 `true` 와 `false` 에 각각 해당하는 플레이어의 돌이 놓인 상태입니다.
6. 여기서 중요한 건 `_boardData`는 이중 배열이므로 인덱스를 두 개 받는데, 첫 번째 인덱스는 게임 판의 행을 위에서부터 아래로 나타내고, 두 번째 인덱스는 게임 판의 열을 왼쪽에서부터 오른쪽으로 나타냅니다.
```
_boardData[i, j]

   --- j 증가 --->
|  +-+-+-+-+-+-+-+
|  |○|○|○|○|○|○|○|
|  +-+-+-+-+-+-+-+
   |○|○|○|○|○|○|○|
i  +-+-+-+-+-+-+-+
   |○|○|○|○|○|○|○|
증 +-+-+-+-+-+-+-+
가 |○|○|○|○|○|○|○|
   +-+-+-+-+-+-+-+
|  |○|○|○|○|○|○|○|
|  +-+-+-+-+-+-+-+
|  |○|○|○|○|○|○|○|
ˇ  +-+-+-+-+-+-+-+
```
7. 다시 말해 `_boardData[3,5]`는 아래 검은 지점을 뜻합니다 (인덱스는 0부터 시작)
```
  +-+-+-+-+-+-+-+
0 |○|○|○|○|○|○|○|
  +-+-+-+-+-+-+-+
1 |○|○|○|○|○|○|○|
  +-+-+-+-+-+-+-+
2 |○|○|○|○|○|○|○|
  +-+-+-+-+-+-+-+
3 |○|○|○|○|○|●|○|
  +-+-+-+-+-+-+-+
4 |○|○|○|○|○|○|○|
  +-+-+-+-+-+-+-+
5 |○|○|○|○|○|○|○|
  +-+-+-+-+-+-+-+
   0 1 2 3 4 5 6
```

#### 3.2. `MakeMove(int col, bool value)` 함수
1. 다시 본론으로 돌아와서, `Board` 클래스는 `MakeMove`함수를 통해 게임판에 수를 둡니다.
2. `MakeMove(3, true)` 와 같이 호출하게 되면, 게임판의 네번째 열(인덱스는 0부터 시작)에 `true` 식별자를 가지는 돌을 집어 넣는겁니다. (쉽게 말해 게임판 네번째 열에 빨간색 돌을 넣습니다)
3. 이 때 게임판 어느 행에 돌이 들어가게 될지를 찾는데, 자리가 있으면 (`if (child._boardData[i,col] == null)`, 34 줄)
4. 그 자리에 입력 받은 식별자를 저장합니다. (`child._boardData[i, col] = value`, 36 줄)
5. 동시에 돌이 들어갔는지 여부도 표시합니다. (`isValid` 변수, 37 줄)
6. 만약 해당 열이 가득 차서 돌이 들어갈 수 있는 자리가 없으면 (43 줄)
7. 예외를 발생 시키고 프로그램을 종료합니다 (44 줄)
8. 돌이 제대로 들어갔으면 해당 돌이 들어간 상태의 게임판을 반환합니다 (46 줄)

#### 3.3. `DetermineState()` 함수
1. `DetermineState` 함수는 현재 게임판의 상태(게임의 종료 여부, 종료 됐을 경우 승리 한 플레이어의 식별자)를 알아내는 함수입니다.
2. `for` 반복문을 3중으로 도는데, 그 중 바깥 2중 `for` 문은 게임판의 행(`i`)과 열(`j`)를 순차적으로 도는 것입니다.
3. `k` 변수를 사용하는 `for` 문은 4가지 방향으로 FOUR IN A ROW 상태인지를 체크하는 반복문입니다.
4. *약간 트릭적인 부분이므로 "이런 방법이 있구나" 정도로 넘어가도 무방합니다.*
5. `k` 값에 따른 방향은 `dRow` (11 줄)와 `dCol` (12 줄)에 의해 결정이 됩니다. 각각 인덱스에 따라 행과 열의 값이 얼마나 바뀌는지 저장해 둔 배열입니다.
6. 즉, `k` 값이 `0` 일 경우 `dRow[0]` 는 `0` 이고 `dCol[0]` 은 `1` 이므로, 열만 하나 증가한 오른쪽 방향을 뜻합니다. 이걸 풀어서 쓰면 다음과 같습니다
```
k = 0 일 때
dRow[k] = 0, dCol[k] = 1 이므로
오른쪽 방향을 뜻함

k = 1 일 때
dRow[k] = 1, dCol[k] = 1 이므로
오른쪽 아래 방향을 뜻함

k = 2 일 때
dRow[k] = 1, dCol[k] = 0 이므로
아래 방향을 뜻함

k = 3 일 때
dRow[k] = 1, dCol[k] = -1 이므로
왼쪽 아래 방향을 뜻함
```
7. 92 줄에서 `IsFourInaARow(i, j, k)` 이렇게 호출하게 되는데, 이는 게임판의 i행 j열에서부터 k방향으로 4개의 돌이 한 줄로 있는지 체크하는 것입니다.
8. 즉, 92 줄은 "게임판의 i행 j열에 누군가의 돌이 놓여 있고, 해당 위치부터 k방향으로 같은 색의 돌이 4개 연속으로 있다면" 이라는 조건이 되는 것입니다.
9. 만약 8번의 조건을 만족했다면 게임이 종료 되었고(`isOver = true`),
게임판 해당 위치에 놓여진 돌의 색깔이 이긴 사람의 색깔이라고 (`winnerIdentifier = _boardData[i, j].Value`) 알려주는
`BoardState` 개체를 생성하여 반환합니다. (93 줄)


### 4. IPlayer.cs

1. `IPlayer` 는 인터페이스입니다.
2. 인터페이스란 쉽게 말해 *"이 클래스는 ~~한 함수들을 가지고 있음"* 이라고 정의해주는 겁니다. (추상 클래스를 알고 있다면 추상 클래스와 비슷한 개념이라고 보면 됩니다)
3. 예를 들어 `IWalkable` 라는 인터페이스가 아래와 같이 있다고 해봅시다
``` csharp
public interface IWalkable
{
   void Walk(int distance);
}
```
4. 이 인터페이스가 뜻하는 바는 명확합니다: *"int 형태의 인자를 하나 받는 Walk라는 함수를 가지고 있음"*
5. 인터페이스는 아래와 같이 쓸 수 있습니다.
``` csharp
public class Human: IWalkable
{
  public void Walk(int distance)
  {
    Console.WriteLine("Human is Walking");
  }
}

public class Dog: IWalkable
{
  public void Walk(int distance)
  {
    Console.WriteLine("Dog is Walking");
  }
}
```
6. 위의 `Human`과 `Dog` 클래스는 `IWalkable` 인터페이스를 구현합니다. 즉, 두 클래스는 모두 `void Walk(int distance)` 라는 함수를 반드시 가지고 있어야 합니다.
7. 위와 같이 선언 한 클래스 두 개는 아래와 같이 쓸 수 있습니다.
``` csharp
IWalkable anmimal;

animal = new Human();
animal.Walk(); // 'Human is Walking' 출력

animal = new Dog();
animal.Walk(); // 'Dog is Walking' 출력
```
8. 즉, 같은 변수의 `Walk` 함수를 호출하더라도 서로 다른 클래스를 변수에 할당해서 다른 동작을 할 수 있게 합니다.
9. 본론으로 돌아와서, 이 프로젝트에서 `IPlayer` 인터페이스는 `string Name`과 `bool Identifier`, 그리고 `int NextMove(Board currentBoard)` 항목들을 가지고 있습니다.
10. 따라서 `IPlayer` 를 구현하는 `HumanPlayer` 와 `AiPlayer` 에서는 `string Name`과 `bool Identifier`, 그리고 `int NextMove(Board currentBoard)` 가 모두 있어야 합니다.
11. 이렇게 해서 얻는 잇점은 `Game` 클래스 32 줄에 `_players[currentPlayer].NextMove(_currentBoard)` 를 호출할 때 현재 플레이어가 AI든 사람이든 관계 없이 동일한 함수 호출로 서로 다른 결과를 얻을 수 있다는 것입니다.
12. 즉, `_players[currentPlayer]` 가 `HumanPlayer` 라면 콘솔(도스창)으로부터 사용자의 입력을 받아 다음 수를 설정할 것이고,
13. `_players[currentPlayer]` 가 `AiPlayer` 라면 AI가 몬테카를로 탐색을 수행하여 다음 수를 설정할 것입니다.
14. 만약 이 프로젝트를 확장하여 네트워크 대전을 집어넣는다고 하면 `IPlayer` 인터페이스를 구현하는 `NetworkPlayer` 클래스 같은 걸 만들어서 네트워크 대전을 구현할 수도 있습니다.


### 5. AiPlayer.cs

#### 5.1. `NextMove(Board currentBoard)` 함수
1. `AiPlayer` 클래스는 현재 게임판의 상태를 가지고 몬테카를로 탐색을 수행하여 다음 수를 정하는 AI 플레이어 클래스입니다.
2. 다른거 보지 말고 `NextMove` 함수부터 집중 해주세요.
3. `NextMove` 함수는 현재 게임판의 상태를 입력으로 받고 다음 수를 출력으로 내어 주는 함수입니다.
4. 각 턴 마다 돌을 놓을 수 있는 경우의 수가 7개 있습니다.
5. 몬테카를로 탐색은 경우의 수를 ***선택***하고, 그 수를 선택 했을 경우에 대한 이후 상황들을 ***시뮬레이션*** 하여 시뮬레이션 결과가 가장 좋은 경우의 수를 최종 선택하는 탐색입니다.
6. 30 ~ 33 줄에서 `for` 반복문을 통해 각 열(인덱스 0 ~ 6)을 선택하여 `SelectAndSimulate` 함수를 호출합니다.
7. 그리고 호출 된 결과(해당 경우의 수를 선택 했을 경우에 대한 휴리스틱 값, 높을 수록 승률 높음)들을 내림차순 정렬해서 가장 이길 확률이 높은 경우의 수(열 인덱스)를 반환합니다.

#### 5.2. `SelectAndSimulate(Board currentBoard, int col, int limit)` 함수
1. `col` 열에 돌을 집어 넣을 경우의 수에 대해 `limit` 만큼의 횟수로 랜덤 시뮬레이션을 돌립니다.
2. 일단 40 줄에서 `col` 열에 돌을 집어넣는 게 가능한 수인지 확인합니다. 만약 아니라면 `-1`의 휴리스틱 값을 반환합니다. (41 줄)
3. 43 ~ 45 줄에서 `limit` 횟수 만큼 `Simulate` 함수를 호출하여 결과 값을 모두 더합니다.
4. 이 때 `Simulate` 함수에는 현재 게임판 상태에서 AI 플레이어가 `col`열에 돌을 집어넣은 상황을 '현재 상태'로써 집어 넣습니다.
5. 3에서 모두 더한 결과 값 즉 `sum` 변수를 반환합니다. (47 줄) 이 값은 `col`열을 선택하는 경우의 수에 대한 휴리스틱 값이 됩니다.

#### 5.3. `Simulate(Board currentBoard)` 함수
1. 입력 받은 게임판 상태를 기초로 랜덤 시뮬레이션을 돌립니다.
2. 52 줄에서 랜덤을 제대로 돌리기 위한 세팅을 수행합니다. [참고 (의사 난수)](https://docs.microsoft.com/ko-kr/dotnet/api/system.random.-ctor?view=netframework-4.8#System_Random__ctor_System_Int32_)
3. 56, 57 줄에서 ***시뮬레이션 상의*** 초기 플레이어를 세팅합니다. 현재 `AiPlayer` 개체의 상대방이 되도록 세팅합니다.
4. 왜냐하면 이미 입력 받은 `currentBoard`는 현재 `AiPlayer` 개체가 둔 수가 반영 되어 있기 때문입니다.
5. 59 ~ 79 줄은 `Game.cs`의 27 ~ 41 줄과 동일합니다. 말 그대로 경우의 수 이후의 게임을 시뮬레이션 하는 거니까 내부적으로 게임이 돌아가고 있는 것과 같습니다.
6. 다른 점은 각 플레이어의 다음 수를 완전히 랜덤으로 지정한다는 것(`move = rnd.Next(0, 7)`, 68 줄)과,
7. 랜덤으로 지정한 열을 체크 해두고(69 줄) 모든 열이 둘 수 없는 곳일 경우(65 줄) 비기는 값 (`0`)을 반환(66 줄)한다는 것 입니다.
8. 만약 게임이 끝날 경우 (79 줄) 승자가 `AiPlayer` 개체 본인이라면(81 줄) 2를, 비겼다면(84 줄) 0을, 졌다면(87 줄) -1을 반환합니다.
9. 이렇게 반환 된 값들은 이 문서 `5.2.5.` 에서 더해지는 결과 값이 됩니다.



## Deep Dive

### `Board` 클래스의 특징 : *Immutable*
`Board` 클래스는 Immutable 하게 구현 되어 있습니다. 즉, `Board` 클래스의 개체는 한 번 생성 되면 내용이 바꿀 수 없습니다.
우리가 흔히 쓰는 언어들은 값을 수정할 수 있습니다. 하지만 이렇게 되면 의도치 않은 값 변경으로 인해 프로그램에 문제가 생기기도 합니다. 이를 부작용이라고 합니다.
부작용을 최소화 하기 위해 아예 패러다임이 다른 부작용이 없는 언어(함수형 언어들)를 만들기도 하지만 프로그램을 구동하는 패러다임이 완전히 달라 이해하기 어려울 수 있습니다.
그래서 여기 `Board` 클래스에서 사용한 방식이 Immutable 이라는 방식입니다. 클래스 외부에서는 값 조회만 가능하고 변경이 불가능하도록 하고, 내부에서도 값 변경을 최소화 하도록 짜는 것입니다.

9 줄에서 `_boardData` 필드를 `private readonly` 한정자로 선언한 이유입니다. `private` 로 선언 했으니 클래스 외부에서는 접근이 불가능합니다. 또, `readonly` 이기 때문에 처음에 값을 설정하고 나면 변경이 불가능하고요.
다만 이는 아래와 같은 헛점이 있어서 완전한 Immutable은 아닙니다. 그래서 여전히 어떤 부분에서 값의 수정이 일어나는지 체크하고 수정을 최소화 할 필요성은 있습니다. `Board` 클래스는 처음 생성하는 23 줄을 제외하면 34 줄에서만 값의 수정이 일어납니다.
``` csharp
_boardData = new bool?[10, 7]; // _boardData에 직접 값을 대입하는 건 readonly 한정자에 위배 되므로 에러가 납니다
_boardData[3,4] = true; // readonly 한정자는 _boardData 변수에 붙어 있을 뿐이라 _boardData[3,4] 에 값을 대입할 수는 있습니다.

// 그렇기에 Board.cs:34 줄에서
child._boardData[i, col] = value;
// 위와 같은 명령이 작동할 수 있는 것입니다.

```
클래스 내용의 변경이 불가능하면 게임판의 상태를 어떻게 변경시킬까요? 바로 게임판을 복제하는 것입니다. 즉, 상태를 ***변경***하는 게 아니라 ***새로운*** 상태를 만드는 것이라고 볼 수 있습니다.
예컨대 `MakeMove(int col, bool value)` 함수는 `col` 열에 `value` 값을 집어넣은 새로운 상태의 `Board` 개체를 생성하여 반환하는 함수입니다. 즉, 기존의 `Board` 개체는 아무런 영향을 받지 않습니다.

이러한 방식을 굳이 `Board` 클래스에 도입 한 주된 이유는 주 게임 상태(`Game.cs`에서 돌아가는 게임)의 흐름는 그대로 유지하면서 그 게임의 현재 상태를 부모 상태로 하는 시뮬레이션 게임들을 돌려야하기 때문입니다.
만약 하나의 `Board` 클래스 개체로 시뮬레이션을 돌리고 끝낼 때 마다 현재 게임 상태를 저장하고, 시뮬레이션을 돌리고, 다시 저장 된 게임 상태를 불러와야 한다면 여간 귀찮은 일이 아닐겁니다. 당연히 오류의 확률도 훨씬 늘어나고요.

또한 이 소스코드를 확장하여 각 경우의 수에 따른 시뮬레이션을 병렬 처리 하게 될 경우 한 가지 상태를 여러 병렬처리 단위(쓰레드)에서 계속 변경하려고 할 것이므로 처리가 아예 되지 않습니다.